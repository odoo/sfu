import { describe, beforeEach, afterEach, expect } from "@jest/globals";
import * as auth from "#src/services/auth.js";
import { AuthenticationError } from "#src/utils/errors.js";

describe("Auth Service", () => {
    const testKey = "TEST2VjcmV0S2V5VGhhdElzMzJCeXRlc0xvbmdBdExldA==";
    const alternateKey = "TESTWx0ZXJuYXRlU2VjcmV0S2V5VGhhdElzMzJCeXRlcw==";
    // token control group generated by a third party.
    const CONTROL_TOKEN = {
        ES512: {
            token: `eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzUxMiJ9.eyJkYXRhIjoidGhpcmQgcGFydHkifQ.AYQOexrkpe58
                    78Q9yImDoRpwzv-ghqAnQf0HI4xoXnY42myZ-WOffaQCVHC3RRgc0ft3iZWHbyqJZrR_66EeP3TKAVUZ
                    Ja9G3IEqb8dTlj4QedzSqCrmyWHemotwuleUDlK-qvZL57L-HftmD3PWE6sVAFDZXTvICUsWemXPsdIo
                    FhjO`,
            publicKey: `-----BEGIN PUBLIC KEY-----
                        MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBh4Cv4rcExpKWeuOazO4l05gGy0Yl
                        /SK0zZNMbCxo7T5wZxeivx/Qs9dsH0H+AsrubS2HeiRfPKkiur6qBMywyKAAYt2/
                        3ZoBGbp597+wQnJEn6fggHGExFObrAh7wBmGWR0tbHMTJ+6yJctkeifU2C39Dx38
                        9hZitslVZLtWucrTlsk=
                        -----END PUBLIC KEY-----
                        `,
            privateKey: `-----BEGIN PRIVATE KEY-----
                        MIHuAgEAMBAGByqGSM49AgEGBSuBBAAjBIHWMIHTAgEBBEIBFR87FuPU7Ic0Yrl3
                        H7CpJEe2vaXPjbfzKCgg3kl8mfsSv/KT8osWezIzM/OehSiv0uaDSn5d4iPRd9MM
                        bQeJnp+hgYkDgYYABAGHgK/itwTGkpZ645rM7iXTmAbLRiX9IrTNk0xsLGjtPnBn
                        F6K/H9Cz12wfQf4Cyu5tLYd6JF88qSK6vqoEzLDIoABi3b/dmgEZunn3v7BCckSf
                        p+CAcYTEU5usCHvAGYZZHS1scxMn7rIly2R6J9TYLf0PHfz2FmK2yVVku1a5ytOW
                        yQ==
                        -----END PRIVATE KEY-----
                        `,
            header: { alg: "ES512", typ: "JWT" },
            payload: { data: "third party" },
        },
        HS256: {
            token: `eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJkYXRhIjoidGhpcmQgcGFydHkifQ.GadSPivgAXYx
                    ftSwH9LKEdg5hv05x1Lihln_6x01TxY`,
            key: testKey,
            header: { alg: "HS256", typ: "JWT" },
            payload: { data: "third party" },
        },
    };
    beforeEach(() => {
        auth.start(testKey);
    });
    afterEach(() => {
        auth.close();
    });
    test("should sign and verify a valid JWT", () => {
        const payload = {
            iss: "test-issuer",
            sub: "1234567890",
            channelUUID: "channel-123",
            iat: Math.floor(Date.now() / 1000),
        };
        const token = auth.sign(payload);
        const result = auth.verify(token);
        expect(result).toEqual(payload);
    });
    test("should verify a token signed by a third party", () => {
        const payload = auth.verify(CONTROL_TOKEN.HS256.token, CONTROL_TOKEN.HS256.key);
        expect(payload).toEqual(CONTROL_TOKEN.HS256.payload);
    });
    test("should verify a token with a specific key", () => {
        const payload = { sub: "1234567890", name: "Test User" };
        const token = auth.sign(payload, alternateKey);
        const result = auth.verify(token, alternateKey);
        expect(result).toEqual(payload);
    });
    test("should reject a token signed with the wrong key", () => {
        const payload = { sub: "1234567890", name: "Test User" };
        const token = auth.sign(payload, alternateKey);
        expect(() => auth.verify(token)).toThrow(AuthenticationError);
    });
    test("should reject a token with tampered payload", () => {
        const payload = { sub: "1234567890", name: "Test User" };
        const token = auth.sign(payload);
        const [header, , signature] = token.split(".");
        const tamperedPayload = auth.base64Encode(
            JSON.stringify({ sub: "1234567890", name: "Hacker" })
        );
        const tamperedToken = `${header}.${tamperedPayload}.${signature}`;
        expect(() => auth.verify(tamperedToken)).toThrow(AuthenticationError);
        // Verify that the original token is still valid
        const result = auth.verify(token);
        expect(result).toEqual(payload);
    });
    test("should reject an expired token", () => {
        const payload = {
            sub: "1234567890",
            exp: Math.floor(Date.now() / 1000) - 3600,
        };
        const token = auth.sign(payload);
        expect(() => auth.verify(token)).toThrow(AuthenticationError);
    });
    test("should reject a token that is not valid yet", () => {
        const payload = {
            sub: "1234567890",
            nbf: Math.floor(Date.now() / 1000) + 3600,
        };
        const token = auth.sign(payload);
        expect(() => auth.verify(token)).toThrow(AuthenticationError);
    });
    test("should reject a token issued in the future (beyond clock skew)", () => {
        const payload = {
            sub: "1234567890",
            iat: Math.floor(Date.now() / 1000) + 120,
        };
        const token = auth.sign(payload);
        expect(() => auth.verify(token)).toThrow(AuthenticationError);
    });
    test("should accept a token with future iat within clock skew", () => {
        const payload = {
            sub: "1234567890",
            iat: Math.floor(Date.now() / 1000) + 30,
        };
        const token = auth.sign(payload);
        const result = auth.verify(token);
        expect(result).toEqual(payload);
    });
    test("should reject a malformed token", () => {
        const malformedTokens = [
            Math.infinity,
            0,
            1,
            { alg: "HS256", typ: "JWT" },
            "",
            "true",
            "0x00",
            "string",
            "not.a.jwt",
            "not.enough.segments.here",
            "header.payload",
            "header..signature",
            "..signature",
            "invalid-base64.payload.signature",
            "header.invalid-base64.signature",
            "header.payload.invalid-base64",
        ];
        for (const token of malformedTokens) {
            expect(() => auth.verify(token)).toThrow(AuthenticationError);
        }
    });
    test("should handle tokens with different padding correctly", () => {
        const payloads = [
            { a: "1" },
            { ab: "12" },
            { abc: "123" },
            { abcd: "1234" },
            { abcd: "12345" },
        ];
        for (const payload of payloads) {
            const token = auth.sign(payload);
            const result = auth.verify(token);
            expect(result).toEqual(payload);
        }
    });
    test("signing should fail with an unsupported algorithm", () => {
        expect(() => auth.sign({ payload: "abc" }, testKey, { algorithm: "HS512" })).toThrow(
            "Unsupported algorithm: HS512"
        );
    });
    test("verifying should fail with an unsupported algorithm", () => {
        expect(() => auth.verify(CONTROL_TOKEN.ES512.token, CONTROL_TOKEN.ES512.publicKey)).toThrow(
            "Unsupported algorithm: ES512"
        );
    });
});
